\chapter{Аналитическая часть}

%\addcontentsline{toc}{section}{Аналитическая часть}

В этом разделе проводится анализ существующих алгоритмов построения трехмерного изображения, генерации текстур и освещения и выбираются наиболее подходящие алгоритмы для решения поставленных задач.


\subsection{Алгоритмы генерации водной поверхности}

Для водной анимации и рендеринга разработан ряд методов. Наиболее реалистичными являются те, которые основаны на гидродинамике и быстром преобразовании Фурье (например, Tessendorf 2001). Эти методы обеспечивают очень реалистичные результаты, но, к сожалению, они требуют значительного объема вычислений, что делает их непригодными для большой части интерактивных приложений.

С другой стороны, большинство проектов в настоящее время используют очень простые модели воды, большинство из которых используют карты нормалей или сеточный метод. К сожалению, эти подходы не могут обеспечить достаточного реализма и не точно воспроизводят волны на поверхности.

\subsection*{Сеточный метод}

Сеточный метод предполагает дискретизацию потока жидкости с помощью введения двухмерной сетки и моделирование поверхности жидкости как движение её между узлами сетки. Зачастую данный способ называют разбиением на полигоны.

Сеточные методы более точны, чем методы взаимодействия частиц, т.к. вычисления легче проводить с регулярной сеткой, чем с неупорядоченным набором частиц. Более того, использование регулярной сетки позволяет упростить геометрию моделируемой водной поверхности, получить более качественное изображение гладкой поверхности воды, к тому же, к координатам каждой вершины сетки легко получить доступ через двухмерный массив вершин. Хоть данный метод и является достаточно удобным для динамической симуляции жидкости, но он не является сильно выигрышным по скорости, т.к. вычисления будут производиться несколько дольше, чем с использованием, например, метода Лагранжа. С помощью сеточных методов невозможно моделировать некоторые трёхмерные свойства жидкости, например, разбивающиеся волны океана. 

Данный метод подходит для симуляции обычных волн в реальном времени.

\subsection*{Метод Лагранжа}

Всю сложность движущихся потоков жидкости способна описать система уравнений Навье-Стокса(1). Это физический подход к моделированию водной поверхности. Он позволяет получать реалистичную модель поверхности жидкости, но требует большого количества вычислительных ресурсов.


\begin{flushleft}
	Уавнений Навье-Стокса:
\end{flushleft}
\begin{equation*} 
	\begin{cases}
		\frac{\partial\vec{u}}{\partial t} + \vec{u} + \frac{1}{\rho}\nabla p = \vec{F} + v\nabla * \nabla\vec{u}\\
		\nabla * u = 0
	\end{cases}
	\eqno(1)
\end{equation*}

Одним из решений этого уравнения и является метод Лагранжа.
В нём жидкость рассматривается как набор частиц, подчиняющихся физическим законам. Каждая частица имеет набор параметров, таких, как масса, скорость и др. и может оказывать влияние на соседние частицы. Но у данного метода есть недостаток, для детализированной визуализации большого объема воды требуется огромное число частиц, что приводит к высоким требованиям к вычислительным ресурсам.


\subsection{Алгоритмы генерации морской волны}

\subsection*{Наложение карт высот}

Данная модель водной поверхности основана на наложении нескольких карт высот, составленных как в пространстве, так и во времени. Каждая текстура представляет одну «гармонику» или «октаву» спектра, и текстуры складываются вместе. Эти текстуры называются картами высот, потому что каждое значение представляет высоту соответствующей точки над горизонтальной плоскостью.

С помощью карт высот художники могут легко управлять параметрами водной анимации вплоть до отдельных волн (см. рисунок 3). Комбинируя несколько карт высот с разными пространственными и временными масштабами, мы можем добиться сложной анимации. Этого достаточно для моделирования движущихся поверхностей океана на масштабах от 10 см до 40 км.


\begin{figure}[h]
	\center{\includegraphics[scale=1.0]{ver.png}}
	\caption{пример карты высот}
\end{figure}



\subsection*{Линеаризованные волны на воде}

Теория волн Эйри - это линейная модель, которая аппроксимирует движение поверхностных волн на водоеме суммой синусоидальных функций (2):

\begin{equation*} 
	\eta(\vec{x}, t) = \eta_{0} + \sum\limits_{i=1}^N a_{i} sin(\omega_{i} \cdot (\phi_{i}(\vec{x}) + t))
	\eqno(2)
\end{equation*}



где $\eta$ - высота воды, $\eta_{0}$ - произвольное постоянное смещение, $a_{i}$ - амплитуда волны $i$, $\omega_{i}$ - угловая частота, $t$ - текущее время, а $\phi_{i}$ - тщательно выбранная фазовая функция.

Каждая волна имеет угловую частоту $\omega$, которая описывает, насколько быстро она колеблется во времени. Для поверхностных водных волн угловая частота определяется дисперсионным соотношением:

\begin{equation*} 
	\omega = \sqrt{(gk + \frac{\sigma}{\rho}k^3) tanh(kh)}
	\eqno(3)
\end{equation*}

где $g$ - сила тяжести, $\sigma$ - поверхностное натяжение, $\rho$ - плотность воды, $h$ - глубина воды в данном месте, а $k$ - волновое число. Волновое число обратно связано с длиной волны $\lambda$ соотношением $k = 2\pi / \lambda$. Каждая волна распространяется в пространстве со скоростью, определяемой фазовой скоростью c.


\subsection*{Волны Герстнера}

Для эффективного моделирования нам необходимо контролировать крутизну наших волн. Cинусоидальные волны имеют округлый вид, что может быть именно тем, что нам нужно для спокойного пасторального пруда. Но для бурного моря или океана нам нужно формировать более острые пики и более широкие впадины. Именно для этого и подходят волны Герстнера.

Выделим набор параметров для определения каждой волны(рис. 4).
Длина волны ($L$): расстояние от гребня до гребня между волнами в мировом пространстве. Длина волны $L$ относится к частоте $w$ как $w$ = $2/L$.
Амплитуда ($A$): высота от водной плоскости до гребня волны.
Скорость ($S$): расстояние, на которое гребень перемещается вперед в секунду. Скорость удобно выразить как фазовую постоянную $\phi$, где $\phi$ = $S x 2/L$.
Направление ($D$) : горизонтальный вектор, перпендикулярный фронту волны, по которой движется гребень.

\begin{figure}[h]
	\center{\includegraphics[scale=1.0]{4.jpg}}
	\caption{пример гармонической волны и её параметров}
\end{figure}

Из данных параметров волны выделим функцию высоты волны:

\begin{equation*} 
	H(x, y, t) = \sum(A_{i} \times sin(D_{i} \cdot (x, y) \times \omega_{i} + t \times \varphi_{i}))
	\eqno(4)
\end{equation*}

%\newpage
Теперь обратимся волновой функции Герстнера:

\begin{equation*} 
	P(x, y, t) = 
	\begin{pmatrix}
		x + \sum(Q_{i}A_{i} \times D_{i}x \times cos(\omega_{i}D_{i} \cdot (x, y) + \varphi_{i}t)),\\
		y + \sum(Q_{i}A_{i} \times D_{i}y \times cos(\omega_{i}D_{i} \cdot (x, y) + \varphi_{i}t)),\\
		\sum(A_{i} sin(\omega_{i}D_{i} \cdot (x, y) + \varphi_{i}t))
	\end{pmatrix}
	\eqno(5)
\end{equation*}

$Q_{i}$ - параметр, контролирующий крутизну волн. Для одной волны $i$ , $Q_{i}$ от 0 дает обычную синусоидальную волну, и $Q_{i} = 1/(w_{i}A_{i})$ дает острый гребень. Следует избегать больших значений $Q_{i}$, поскольку они вызовут образование петель над гребнями волн. Фактически, мы можем оставить спецификацию Q в качестве параметра «крутизны» для художника-постановщика, разрешив диапазон от 0 до 1 и используя $Q_{i} = Q/(w_{i}A_{i} \times numWaves)$, чтобы варьироваться от абсолютно гладких волн до самых резких, которые мы можем произвести.

Именно данная функция(5) способна моделировать волны с сильными гребнями(см рис. 5).

\begin{figure}[h]
	\center{\includegraphics[scale=1.0]{5.jpg}}
	\caption{пример волн, полученных алгоритмом Герстнера}
\end{figure}

\subsection{Алгоритмы удаления невидимых линий и поверхностей}

Для того чтобы выбрать подходящий алгоритм построения изображения, необходимо провести обзор известных алгоритмов и осуществить выбор наиболее подходящих для решения поставленных задач.

\subsection*{Алгоритм Робертса}

Алгоритм Робертса представляет собой первое известное решение задачи об удалении невидимых линий. Этот метод работает в объектном пространстве. Алгоритм прежде всего удаляет из каждого тела те ребра или грани, которые перекрываются самим телом. Затем все видимые рёбера каждого тела сравниваются с каждым из оставшихся тел для определения того, какая его часть или части, если таковые есть, перекрываются этими телами.
 
Преимущества данного алгоритма в том, что математические методы, используемые в нем просты, мощны и точны. Более поздние реализации алгоритма, например, использующие предварительную сортировку вдоль оси z, демонстрируют почти линейную зависимость от числа объектов.
Минус этого алгоритма в том, что теоретически вычислительная трудоемкость алгоритма Робертса растет как квадрат числа объектов. Реализация оптимизированных алгоритмов весьма сложна.

\subsection*{Алгоритм Варнока}
Алгоритм Варнока работает в пространстве изображений. В данном пространстве рассматривается окно и решается вопрос о том, пусто ли оно, или его содержимое достаточно просто для визуализации. Если это не так, то оно разбивается на фрагменты до тех пор, пока содержимое фрагмента не станет достаточно простым для визуализации или его размер не достигнет требуемого предела разрешения.
 
Для каждой подобласти (окна) определяются связанные с ней многоугольники и те из них, видимость которых определить "легко", изображаются на экране. В противном же случае разбиение повторяется, и для каждой из вновь полученных подобластей рекурсивно применяется процедура принятия решения.

Предполагается, что с уменьшением размеров области ее перекрывает все меньшее и меньшее количество многоугольников. Считается, что в пределе будут получены области, содержащие не более одного многоугольника, и решение будет принято достаточно просто. Если же в процессе разбиения будут оставаться области, содержащие не один многоугольник, то следует продолжать процесс разбиения до тех пор, пока размер области не станет совпадать с одним пикселом. В этом случае для полученного пикселя необходимо вычислить глубину (значение координаты Z) каждого многоугольника и визуализировать тот из них, у которого максимальное значение этой координаты.


\subsection*{Алгоритм трассировки лучей}
В этом методе для каждого пикселя картинной плоскости определяется ближайшая к нему грань, для чего через этот пиксель выпускается луч, находятся все его пересечения с гранями и среди них выбирается ближайшая.
 
К достоинствам данного алгоритма можно отнести возможность получения изображения гладких объектов без аппроксимации их примитивами (например, треугольниками). Вычислительная сложность метода линейно зависит от сложности сцены. Нетрудно реализовать наложение света и тени на объекты. Качество полученного изображения получается очень реалистичным, этот метод отлично подходит для создания фотореалистичных картин.

Серьёзным недостатком данного алгоритма является его производительность. Для получения изображения необходимо создавать большое количество лучей, проходящих через сцену и отражаемых от объекта. Это приводит к существенному снижению скорости работы программы.


\subsection*{Алгоритм, использующий z-буфер}
Это один из простейших алгоритмов удаления невидимых поверхностей, который работает в пространстве изображения. Здесь обобщается идея о буфере кадра. Буфер кадра используется для заполнения атрибутов (интенсивности) каждого пикселя в пространстве изображения. Так же вводится Z-буфер, представляющий собой специальный буфер глубины, в котором запоминаются координаты Z (глубина) каждого видимого пикселя. В процессе работы глубина каждого нового пикселя, который надо занести в буфер кадра, сравнивается с глубиной того пикселя, который уже занесен в Z-буфер. Если это сравнение показывает, что новый пиксель расположен ближе к наблюдателю, чем пиксел, уже находящийся в буфере кадра, то уже новый пиксель заносится в буфер кадра. Помимо этого, производится корректировка Z-буфера: в него заносится глубина нового пикселя. Если же глубина нового пикселя меньше, чем хранящегося в буфере, то никаких действий производить не надо. В сущности, алгоритм для каждой точки (x,y) находит наибольшее значение функции Z(x,y).

Несмотря на свою простоту, этот алгоритм позволяет удалять сложные поверхности и визуализировать пересечения таких поверхностей. Сцены могут быть произвольной сложности, а поскольку размеры изображения ограничены размером экрана дисплея, то трудоемкость алгоритма имеет линейную зависимость от числа рассматриваемых поверхностей. Элементы сцены заносятся в буфер кадра в произвольном порядке, поэтому в данном алгоритме не тратится время на сортировки, которые необходимы в других алгоритмах.

\subsection{Анализ моделей освещения}

\subsection*{Затенение по Гуро}
Закраска по Гуро хорошо сочетается с диффузным отражением. Данный метод интерполяции обеспечивает лишь непрерывность значений интенсивности вдоль границ многоугольников, но не обеспечивает непрерывность изменения интенсивности, следовательно, возможно появление полос Маха.

Метод Гуро является одним из способов устранения дискретности интенсивностей закрашивания.
\newline\newline
Данный алгоритм предполагает следующие шаги:
\begin{enumerate}
	\item Вычисление векторов нормалей к каждой грани.
	\item Вычисление векторов нормали к каждой вершине грани путем усреднения нормалей к граням (см. рисунок 1)
	\item Вычисление интенсивности в вершинах грани.
	\item Интерполяция интенсивности вдоль ребер грани.
	\item Линейная интерполяция интенсивности вдоль сканирующей строки.
\end{enumerate}

\begin{figure}[h]
	\center{\includegraphics[scale=1.0]{guru.png}}
	\caption{вычисление векторов нормали к каждой вершине}
\end{figure}

\subsection*{Модель освещения Ламберта}
Модель Ламберта - простейшая модель освещения, моделирующая идеально диффузное освещение. Считается, что свет, падающий в точку, одинаково рассеивается по всем направлениям полупространства. Таким образом, освещенность в точке определяется только плотностью света в точке поверхности, которая в свою очередь линейно зависит от косинуса угла падения.

Модель освещения Ламберта хорошо работает только для сравни-тельно гладких поверхностей. В отличии от нее модель Орен-Найара основана на предположении, что поверхность состоит из множества микро-граней, освещение каждой из которых описывается моделью Ламберта(см. рисунок 2).

\begin{figure}[h]
	\center{\includegraphics[scale=1.0]{lambert.png}}
	\caption{падение и рассеивание света}
\end{figure}

\subsection*{Модель освещения Фонга}
Модель Фонга – модель освещения, состоящая из диффузной компоненты (модель Ламберта) и зеркальной компоненты. Помимо равномерного освещения, модель реализует блики, появляющиеся на модели. Отраженная составляющая освещенности в точке зависит от того, насколько близки направления вектора, направленного на наблюдателя, и отраженного в сторону наблюдателя луча.  
В модели учитываются интенсивности фоновой и рассеянной компонент освещения, а также глянцевые блики.

\subsection*{Модель освещения Уиттеда}
Модель освещения Уиттеда предназначена для того, чтобы рассчитать интенсивность отраженного к наблюдателю света в каждом пикселе изображения, которая в свою очередь может быть локальной или глобальной. В первом случае во внимание принимается только свет, падающий от источника, и ориентация поверхности. Во втором учитывается свет, отраженный от других объектов сцены или пропущенный сквозь них.
 
Уиттед пользуется моделью с такими же членами рассеянного и ламбертовского диффузного отражения, а также зеркального отражения Фонга, как и в локальной модели освещения. Модель Уиттеда учитывает эффекты преломления и отражения, зеркальности.



\newpage
\section*{Вывод}
Проведенный анализ существующих методов генерации водной поверхности позволяет сделать вывод, что для решения поставленной задачи наилучшим решением будет либо метод Лагранжа, либо сеточный метод. Несмотря на то, что метод Лагранжа выигрывает у сеточного в реалистичности, но мой выбор пал на метод сеточный метод, т.к. он выигрывает в вычислительной сложности.
В качестве метода генерации морской волны был выбран алгоритм Герстнера, он наиболее подходит для моделирования большой водной поверхности (океан, море). Для получения более сглаженного изображения будет использован метод гуро, а также z-buffer для удаления невидимых линий.

